#include "/Engine/Private/Common.ush"
#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/ScreenPass.ush"

// 4x4 Bayer matrix for ordered dithering
static const float bayer4[16] =
{
    0.0 / 16.0, 8.0 / 16.0, 2.0 / 16.0, 10.0 / 16.0,
   12.0 / 16.0, 4.0 / 16.0, 14.0 / 16.0, 6.0 / 16.0,
    3.0 / 16.0, 11.0 / 16.0, 1.0 / 16.0, 9.0 / 16.0,
   15.0 / 16.0, 7.0 / 16.0, 13.0 / 16.0, 5.0 / 16.0
};

// Shder Inputs
SCREEN_PASS_TEXTURE_VIEWPORT(ViewParams)
Texture2D<float4> SceneColorTexture;
SamplerState SceneColorSampler;
float Pixelation;
float NumColors;
float Spread;


float4 MainPS(float4 SvPosition : SV_POSITION) : SV_Target0
{
    // 1. Map absolute pixel position to 0-1 Viewport UV
    // SvPosition is the current pixel on the output target (0 to Width/Height)
    float2 ViewportUV = (SvPosition.xy) * ViewParams_ViewportSizeInverse;

    // 2. Pixelation (Scale based on the actual viewport size)
    float2 PixelCount = ViewParams_ViewportSize / max(1.0, pow(2.0, Pixelation));
    float2 QuantizedViewportUV = (floor(ViewportUV * PixelCount) + 0.5) / PixelCount;

    // 3. Map back to Texture UV (handling the pooling offset)
    float2 SampleUV = QuantizedViewportUV * ViewParams_UVViewportSize + ViewParams_UVViewportMin;

    // 4. Sample
    float3 SceneColor = SceneColorTexture.SampleLevel(SceneColorSampler, SampleUV, 0).rgb;

    // 5. Dither and Quantize
    float2 blockPos = floor(ViewportUV * PixelCount);
    int index = int(fmod(blockPos.y, 4.0)) * 4 + int(fmod(blockPos.x, 4.0));
    float M = Spread * (bayer4[index] - 0.5);
    
    // 6. Color Quantization
    float ColorRange = max(1.0, NumColors - 1.0);
    float3 FinalColor = floor((SceneColor + M) * ColorRange + 0.5) / ColorRange;

    return float4(saturate(FinalColor), 1.0);
}